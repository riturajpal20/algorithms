#include <bits/stdc++.h>
using namespace std;

#define ll long long int
#define vii vector<pair<ll, ll>>
#define ff(i, a, b) for (ll i = a; i < b; ++i)
#define fr(i, a, b) for (ll i = a; i >= b; --i)
#define vs vector<string>
#define vec vector<ll>
#define mpll map<ll, ll>
#define mpcl map<char, ll>
#define mpsl map<string, ll>
#define pb push_back
#define vvi vector<vector<ll>>
#define bs(v, a) binary_search(v.begin(), v.end(), a)
// #define endl

#define srtv(v, n) sort(v.begin(), v.end())
#define isortarry(arr, n) sort(arr, arr + n)
#define dsortarry(arr, n) sort(arr, arr + n, greater<int>())
#define mod 1000000007

ll f(vector<ll> &arr, ll ind, ll k, vector<ll> &dp)
{
    if (ind == 0)
    {
        return 0;
    }
    if (dp[ind] != -1)
    {
        return dp[ind];
    }
    ll maxi = INT_MAX;
    ff(i, 1, k + 1)
    {
        if (ind - i >= 0)
        {
            ll j = f(arr, ind - i, k, dp) + abs(arr[ind] - arr[ind - i]);
            maxi = min(maxi, j);
        }
    }
    return dp[ind] = maxi;
}
// get total set bit
ll getsetbit(ll num)
{
    return __builtin_popcount(num);
}
// check whether it is possible to place cow at min distance of mid or not
bool check(int x, vec &v, ll n, ll k)
{
    ll cnt = 1;
    ll co = v[0];
    ff(i, 1, n)
    {
        if (v[i] - co >= x)
        {
            cnt++;
            co = v[i];
        }
        if (cnt == k)
        {
            return true;
        }
    }
    return false;
}
/*************FIND GCD OF TWO NUMBERS*************/
ll gcd(ll a, ll b)
{
    if (b == 0)
    {
        return a;
    }

    else
    {
        return gcd(a, b % a);
    }
}
/*************FIND LCM OF TWO NUMBERS*************/
ll lcm(ll a, ll b)
{
    return (a * b) / gcd(a, b);
}
// extended euclid
ll egcd(int a, int b, ll &x, ll &y)
{
    if (b == 0)
    {
        x = 1;
        y = 0;
        return a;
    };
    ll x1, y1;
    ll d = egcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - y1 * (a / b);
    return d;
}
/*************POWER OF A TO B*************/
// ll ul = 1e9 + 7;
ll power(ll a, ll b)
{

    ll ans = 1;
    while (b != 0)
    {
        if (b & 1)
        {
            b--;
            ans = (ans * a);
        }
        else
        {
            a = (a * a);
            b /= 2;
        }
    }
    return ans;
}

/*************FIND NUMBER OF DIGIT IN A*************/
ll digits(ll n)
{
    ll k = 0;

    ll q = n;
    while (q > 0)
    {
        q = q / 10;
        k++;
    }
    return k;
}
bool prime(ll n)
{
    if (n == 1 || n == 0)
    {
        return false;
    }
    if (n == 2 || n == 3)
    {
        return true;
    }
    ff(i, 2, sqrt(n) + 1)
    {
        if (n % i == 0)
        {
            return false;
        }
    }
    return true;
}
void factor(ll p, vector<ll> &ans)
{

    for (int i = 2; i * 1ll * i <= p; ++i)
    {
        if (p % i == 0)
        {
            ans.pb(i);
            if (i != p / i)
            {
                ans.pb(p / i);
            }
        }
    }
}

/*************YOUR CODE GOES HERE*************/
// const int N = (int)1e5 + 5;
// int a[N], b[N];
// ll xxx = 1e9;
// string s;
// vec parent(1e5 + 1)
map<ll, ll> parent;
void bfs(ll root, vector<ll> adj[])
{
    queue<pair<ll, ll>> q;
    q.push({root, -1});
    ll height = 0;
    ll maxi = INT_MIN;
    // parent[root] = -1;
    while (!q.empty())
    {

        ll sz = q.size();

        // maxi = max(maxi, sz);

        ll node = q.front().first;
        ll par = q.front().second;
        q.pop();
        parent[node] = par;

        for (auto it : adj[node])
        {
            if (it == par)
            {
                continue;
            }
            q.push({it, node});
        }
    }
}

// factorial function
ll fact(ll n)
{
    if (n == 0)
        return 1;
    ll res = 1;
    for (int i = 2; i <= n; i++)
        res = res * i;
    return res;
}
ll nCr(ll n, ll r)
{
    return fact(n) / (fact(r) * fact(n - r));
}
// ll mod = 1e9 + 7;

// ll n;
map<ll, vector<ll>> mp;
ll ti = 0;
// vec d;
map<ll, ll> m;
vector<ll> d(1e5 + 1);
ll res = 0;
ll N = 2e5 + 1;
vector<ll> path(N, 0);
ll c = 0;
// ll N = 2e5 + 1;
// vector<ll> path(N, 0);
ll sums = 0;
// can i use dp ??
// but how??
void dfs(ll node, ll par, vector<ll> adj[], vec &ans)
{

    for (auto it : adj[node])
    {

        if (it == par)
        {
            continue;
        }
        ans.pb(node);

        dfs(it, node, adj, ans);
    }

    ans.pb(node);
}
// finding square root of number

ll mods = 1000000007;

// all prime factor of a number
const ll N1 = 1e6 + 3;
vec allfs;
ll spf[N1 + 1];
void allf(ll n)
{
    // ll spf[N1 + 1];
    ff(i, 2, N1 + 1)
    {
        spf[i] = i;
    }
    for (ll i = 2; i * i <= N1; i++)
    {
        if (spf[i] != i)
        {
            continue;
        }

        for (ll j = i * i; j <= N1; j += i)
        {

            if (spf[j] == j)
            {
                spf[j] = i;
            }
        }
    }
    while (n != 1)
    {
        allfs.pb(spf[n]);
        n = n / spf[n];
    }
}
// find all prime upto number n
vec allp;
ll N2 = 1e6 + 3;
void sieve(int n)
{

    bool prime[N2 + 1];
    memset(prime, true, sizeof(prime));

    for (int p = 2; p * p <= n; p++)
    {

        if (prime[p] == true)
        {

            for (int i = p * p; i <= n; i += p)
            {
                prime[i] = false;
            }
        }
    }

    for (int p = 2; p <= n; p++)
    {
        if (prime[p])
        {
            allp.pb(p);
        }
    }
}
// comperator function

bool cmp(const pair<ll, ll> &p1, const pair<ll, ll> &p2)
{
    if (p1.first > p2.first)
    {
        return true;
    }
    else if (p1.first == p2.first && p1.second < p2.second)
    {
        return true;
    }
    return false;
}
void dp_on_tree(ll node, vector<ll> adj[], vector<ll> &dp, ll par)
{
    dp[node] = 1;
    for (auto it : adj[node])
    {
        if (it == par)
        {
            continue;
        }
        dp_on_tree(it, adj, dp, node);
        dp[node] += dp[it];
    }
}
// ll sum = 0;

// ll mod = 109 + 7;
void binarylifting(ll node, ll par, vector<ll> adj[], vector<vector<ll>> &dp, vec &level, ll l = 0)
{
    dp[node][0] = par;
    ff(i, 1, 17)
    {

        dp[node][i] = dp[dp[node][i - 1]][i - 1];
    }
    level[node] = l;
    // dfs
    for (auto it : adj[node])
    {
        if (it == par)
        {
            continue;
        }
        binarylifting(it, node, adj, dp, level, l + 1);
    }
}

ll kthparent(ll k, ll node, vector<vector<ll>> &dp)
{
    ll cnt = 0;
    while (k)
    {
        if (k & 1)
        {
            node = dp[node][cnt];
        }
        k = k >> 1;
        cnt++;
    }
    return node;
}

void solve()
{
    ll n;
    cin >> n;
    vec adj[n + 1];
    ff(i, 0, n - 1)
    {
        ll u, v;
        cin >> u >> v;
        adj[u].pb(v);
        adj[v].pb(u);
    }
    vector<vector<ll>> dp(n + 1, vector<ll>(17, 0));
    vec level(n + 1, 0);
    // cout << "hello";
    binarylifting(1, 0, adj, dp, level);
    ll q;
    cin >> q;
    // cout << "hello";
    while (q--)
    {
        ll a, b;
        cin >> a >> b;
        // if a is at higher level than b then just swap them so that a must be at lower level than b
        if (level[a] > level[b])
        {
            swap(a, b);
        }
        ll k = level[b] - level[a];
        b = kthparent(k, b, dp);
        for (ll i = 16; i >= 0; i--)
        {
            if (dp[a][i] != dp[b][i])
            {
                a = dp[a][i];
                b = dp[b][i];
            }
        }
        cout << dp[a][0] << endl;
    }
    cout << "hello";
}

/*************YOUR CODE GOES HERE*************/
int main()
{
    // ll t;
    // cin >> t;

    // while (t--)
    // {
    //     solve();
    // }
    solve();

    return 0;
}